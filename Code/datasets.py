import torch
from torch.utils.data import Dataset
import numpy as np
import pandas as pd
from tqdm import tqdm

class CNN1D_Dataset(Dataset):
    def __init__(self, dataframe,mask=None):
        def _split_formula(x: str):
            if "i" in x or "l" in x or "r" in x:
                tmp = list(x)
                NML = set(("Si", "Cl", "Br"))
                i = 0
                while i < len(tmp) - 1:
                    t_str = tmp[i] + tmp[i + 1]
                    if t_str in NML:
                        tmp[i] = t_str
                        tmp.pop(i + 1)
                    i += 1
                return np.array(tmp)
            else:
                return np.array(list(x))
        
        def _make_index(unique_formulas):
            d0=dict(zip(unique_formulas,range(len(unique_formulas))))
            d=np.zeros((len(self.str_formulas)))
            for i,val in enumerate(self.str_formulas):
                idx=d0[val]
                d[i]=idx
            return d.astype(int)
        
        def _encode_smiles(line):
            arr = np.zeros((len(self.SYMS), self.max_len))
            pad = (self.max_len-len(line))//2
            for i, sym in enumerate(line):
                arr[self.D_SYM.get(sym), i + pad] = 1
            return arr

        def _encode_column(col_type):
            res = np.zeros((37))
            res[col_type] = 1
            if col_type > 14:
                res[-1] = 1
            return res
        
        if mask is not None:
            df=dataframe.iloc[mask].copy()
        else:
            df=dataframe
        self.SYMS = [
            '#', '(', ')', '+', '-', '1', '2', '3', '4', '5', '6', '7', '8',
            '9', '=', 'Br', 'B', 'Cl', 'C', 'F', 'H', 'I', 'N', 'O', 'P', 'Si',
            'S', '[', ']', 'c', 'n', 'o', 's'
        ]
        self.D_SYM = dict(zip(self.SYMS, range(len(self.SYMS))))
        unique_formulas=pd.unique(df["Formula"]).tolist()
        self.str_formulas=df["Formula"].values
        self.index=_make_index(unique_formulas)
        self.max_len = 256
        self.ris = df["RI"].values/1000
        self.cols = df["ColType"].values
        split_formulas=list(map(_split_formula,unique_formulas))
        self.enc_formulas=list(map(_encode_smiles,tqdm(split_formulas)))
        self.enc_columns=np.vstack(list(map(_encode_column,range(37))))
        

    def __getitem__(self, index):
        smiles_encoded = torch.FloatTensor(self.enc_formulas[self.index[index]])
        col_encoded = torch.FloatTensor(self.enc_columns[self.cols[index]])
        return (smiles_encoded, col_encoded, self.ris[index])

    def __len__(self):
        return len(self.ris)
    
class CNN2D_Dataset(Dataset):
    """Dataset class for CNN2D neural network.
    It uses pre-generated by RdKit 2D images stored as numpy arrays
    and distributes them along with encoding types of columns."""

    def __init__(self, dataframe, en_2d, unique_formulas, mask=None):

        def _make_index(formulas, unique_formulas):
            d0 = dict(zip(unique_formulas, range(len(unique_formulas))))
            d = np.zeros((len(formulas)))
            for i, val in enumerate(formulas):
                idx = d0[val]
                d[i] = idx
            return d.astype(int)

        def _encode_column(col_type):
            res = np.zeros((37))
            res[col_type] = 1
            if col_type > 14:
                res[-1] = 1
            return res

        if mask is not None:
            df = dataframe.iloc[mask].copy()
        else:
            df = dataframe
        self.index = _make_index(df["Formula"].values, unique_formulas)
        self.ris = df["RI"].values / 1000
        self.cols = df["ColType"].values
        self.en_2d = torch.FloatTensor(en_2d)
        self.enc_columns=torch.FloatTensor(np.vstack(list(map(_encode_column,range(37)))))

    def __getitem__(self, index):
        col_encoded = self.enc_columns[self.cols[index]]
        en_2d = self.en_2d[self.index[index]]
        return (en_2d, col_encoded, self.ris[index])

    def __len__(self):
        return len(self.ris)
    
class MLP_Dataset(Dataset):
    """Dataset class for MLP neural network.
    It uses pre-generated molecular descriptors, molecular fingerprints, 
    MACCS keys of a molecule along with encoding types of columns."""
    def __init__(self, dataframe,descriptors,fingerprints,unique_formulas,maccs,mask=None): 
        def _make_index(formulas, unique_formulas):
            d0=dict(zip(unique_formulas,range(len(unique_formulas))))
            d={}
            for i,val in enumerate(formulas):
                idx=d0.get(val,None)
                if idx is None:
                    print(f"Formula error: {val}")
                d[i]=idx
            return d
        
        def _encode_column(col_type):
            res = np.zeros((37))
            res[col_type] = 1
            if col_type > 14:
                res[-1] = 1
            return res

        if mask is not None:
            df=dataframe.iloc[mask].copy()
        else:
            df=dataframe
        self.maccs=maccs
        self.md = descriptors
        self.fp=fingerprints
        self.index=_make_index(df["Formula"].values, unique_formulas)
        self.ris = df["RI"].values/1000
        cols = df["ColType"].values
        self.en_cols=np.vstack(list(map(_encode_column,cols)))

    def __getitem__(self, index):
        descriptors = torch.FloatTensor(self.md[self.index[index]])
        fingerprints= torch.FloatTensor(self.fp[self.index[index]])
        maccs=torch.FloatTensor(self.maccs[self.index[index]])
        col_encoded = torch.FloatTensor(self.en_cols[index])
        return (descriptors, fingerprints, maccs, col_encoded, self.ris[index])

    def __len__(self):
        return len(self.ris)